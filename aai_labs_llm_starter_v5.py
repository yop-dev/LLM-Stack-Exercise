# -*- coding: utf-8 -*-
"""AAI Labs LLM Starter v5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jP7BDvw7DtEs01-pgANr3lxj4XRUmPL6

# AAI Labs LLM Stack Exercise


❗Please ensure that you don't share your solution with anybody else - in case of plagiarism, we will automatically fail any party involved
"""

!gsutil cp gs://aai-labs-public-downloads/datasets/archive_wiki_stem_articles.zip .

!unzip archive_wiki_stem_articles.zip -d archive_wiki_stem_articles/

!ls

!pip install haystack-ai datasets transformers

from datasets import load_from_disk

dataset = load_from_disk('archive_wiki_stem_articles')
print(dataset)

"""# Goal

This exercise will test your problem solving skills in LLM-space using [Haystack](https://docs.haystack.deepset.ai/docs/intro) and custom-coding skills.


# Exercise steps

1. Train Llama model (any size) to classify `text` into `section`.
  - It should produce a probability of the text being each class.
  - Classify it using top-10 sections by frequency + "other" section
  - Show train/test classification report (f1, recall, precision)
2. Integrate the resulting model as a DocumentClassification component in a Haystack
3. Create a Pipeline to classify custom-created documents into `section`.
 - Write 10 examples
 - Show their resulting sections
4. Create QA Pipeline
 - Only answer questions about `History` section
 - Answers should be based on the records available in the dataset
 - Log all other questions into a file or local DB using Haystack writers
 - Everything should be implemented using Haystack tools (Pipelines, Components, Retrievers)
5. Write a function to display captured records from the file/DB

# Submissions
Send back link to your notebook. Ensure that code executes and all the cells work and there are no errors

Ensure you understand everything you wrote and how different pieces of the system work.

# Hints
 - use [libraries from HuggingFace](https://huggingface.co/docs/transformers/en/index) to work with Llama model
 - if Colab doesn't provide you with enough memory, try using Kaggle Notebooks (but Colab is preferred)

---

# **Joner De Silva - Solution**

---

## LLM Classification + QA Pipeline  
AAI Labs LLM Starter Exercise – Haystack v2.15

---

># Overview  
This project demonstrates how I fine-tuned a Transformer model (DistilBERT) to classify Wikipedia text sections, integrated that classifier into a Haystack pipeline, and built a QA system that only answers questions related to the "History" section.

---

>## Features Implemented

- Fine-tuned DistilBERT model to classify the top 10 most frequent sections + "other"
- Wrapped the model as a custom DocumentClassificationComponent for use with Haystack
- Created a classification pipeline to annotate incoming documents
- Built a Question Answering (QA) pipeline using InMemoryBM25Retriever and a custom SimpleHistoryReader to generate responses from history-related documents
- Configured the QA system to:
  - Only answer questions if the user query is classified under the "History" section
  - Log all non-history questions to a JSON file using a custom Haystack component (`NonHistoryLogger`)
 - Included a function to read and display the logged questions (`non_history_questions.json`)


---

>## Model Training Strategy

### Why DistilBERT over LLaMA?

LLaMA-based models were initially considered due to their strong performance on language tasks.  
However, due to **Google Colab’s resource limitations (especially memory and GPU constraints)**, I opted for **DistilBERT**, a lightweight yet effective alternative. DistilBERT offers a good balance between speed and performance, making it practical for training and inference in constrained environments.

- Produced the probabilty of text being in the predicted top-3 classes
- Classified using top-10 sections + other
- Showed train/test classification reports (Included Confusion Matrices and + other useful reports)

---

># Smart Dataset Selection  

Due to resource limitations, I didn’t use the entire 2 million row Wikipedia dataset.  
Instead, I used a smart balancing strategy to extract ~76,000 samples, by:

- Selecting the top 10 most frequent sections
- Assigning all other section labels into an "other" category
- Ensuring a relatively balanced class distribution while retaining natural frequencies

This final dataset was used for both training and evaluation of the classification model.

>Why This Approach Is Effective

In real-world NLP datasets, certain sections are far more common than others — leading to **class imbalance** that harms model performance. To address this without losing the natural structure of the data, I implemented a **smart balanced sampling strategy** based on:


| Problem | Solution | Benefit |
|--------|----------|---------|
| ⚠️ Dominant classes overwhelm the model | Scale sampling by √(class proportion) | Retains real-world frequency while softening imbalance |
| ⚠️ Rare classes get ignored | Minimum 3,000 samples per class | Ensures model learns from all sections |
| ⚠️ Overfitting on frequent labels | Cap each class at 15,000 max | Keeps model generalizable and balanced |
| ⚠️ Rigid balancing leads to unnatural data | Square-root scaling | Smooth, realistic class distribution |

This smart sampling ensures a **robust, fair, and production-ready classifier**, balancing practicality with performance.

---

># Custom Document Classification

As part of the requirements:

 **Create a Pipeline to classify custom-created documents into section. Write 10 examples. Show their resulting sections.**

This requirement was fulfilled by implementing a `DocumentClassificationComponent` using the fine-tuned DistilBERT model and integrating it into a Haystack-compatible pipeline.

To ensure robustness and transparency in classification, I tested the classifier on two kinds of documents:

-  **Real documents** sampled from the training dataset (with known ground-truth labels)
-  **Custom-written documents** with varied topics, not present in the original dataset

## Why both?

Using **real documents** with true labels allowed me to evaluate how well the model generalizes to previously seen distribution and provides an immediate benchmark for classification quality. The presence of the true label enables direct accuracy checks.

Meanwhile, **custom documents** simulate unseen, real-world inputs. These were written to represent common questions or text snippets a user might ask in a production setting. Since they don’t have ground truth labels, their classification demonstrates how the model might behave in live use cases.

Both types were processed using the same classification pipeline. For each document, I printed:

- Text preview
- Predicted section
- Confidence score
- Top-3 predicted classes

This thorough test satisfies the requirement while validating both classification accuracy (on known samples) and generalization (on unseen text).

---

># QA Pipeline Implementation

**Two Implementation Approaches**

I've provided two implementations to demonstrate different architectural approaches:

>### Implementation 1: ML Model Only (High Accuracy)

- Uses trained model exclusively
- Fails fast if model unavailable
- Best for production with reliable ML infrastructure
- Prioritizes accuracy and consistency

>### Implementation 2: ML with Keyword Fallback (High Reliability)

- Primary: Trained ML model
- Fallback: Keyword-based classification
- Best for environments where uptime is critical
- Prioritizes system reliability and deployment flexibility

The choice depends on the production requirements - whether you prioritize maximum accuracy or maximum uptime. This demonstrates understanding of real-world trade-offs in system design and different deployment scenarios.

>### QA Pipeline Questions

For the QA pipeline, I tested the system using 8 total questions:

- 4 questions were taken directly from the smart_balanced_dataset, ensuring relevance to actual context and verifying classification alignment.
- 4 additional questions were randomly written to simulate real-world user behavior and evaluate how well the system filters and logs unrelated or non-history questions.

This strategy ensured that the pipeline was tested both on in-domain (labeled) and out-of-domain (unseen or irrelevant) examples.

>### Performance Results

| Model Variant     | Accuracy | F1 Score | Notes                        |
|-------------------|----------|----------|------------------------------|
| ML-only           | 3/4      | -        | Missed 1 valid history query |
| ML + Keyword Fallback | 4/4  | -        | Handled edge case properly   |

Interestingly, the fallback version achieved 4/4 correct classifications on history questions, while the ML-only version achieved 3/4. This demonstrates several important points:

- Fallbacks can improve robustness: The hybrid approach caught edge cases that the pure ML model missed
- ML models aren't always perfect: Even trained models can have confidence threshold issues or misclassify certain inputs
- System design matters: Sometimes a well-designed hybrid system outperforms a single-method approach

This real-world result reinforces why production systems often benefit from multiple validation layers rather than relying solely on a single ML model.

---
"""

import haystack
print(haystack.__version__)

"""**Install added required packages**"""

!pip install torch accelerate peft bitsandbytes scikit-learn pandas numpy tqdm
!pip install sentence-transformers faiss-cpu

# Disable wandb integration completely
import os
os.environ["WANDB_DISABLED"] = "true"

import json
import pandas as pd
import numpy as np
from collections import Counter
from datasets import load_from_disk, Dataset
from transformers import (
    AutoTokenizer, AutoModelForSequenceClassification,
    TrainingArguments, Trainer, DataCollatorWithPadding
)
from sklearn.metrics import classification_report, f1_score
from sklearn.preprocessing import LabelEncoder
import torch
from torch.utils.data import DataLoader
from tqdm import tqdm
import warnings
warnings.filterwarnings('ignore')

# Load the dataset
dataset = load_from_disk('archive_wiki_stem_articles')
print(f"Dataset info: {dataset}")
print(f"Features: {dataset.features}")
print(f"Number of rows: {len(dataset)}")

# Let's explore the data
df = dataset.to_pandas()
print(f"\nDataset shape: {df.shape}")
print(f"\nSection distribution (top 20):")
section_counts = df['section'].value_counts()
print(section_counts.head(20))

"""**Train the model to classify text into section**"""

# Get top 10 sections by frequency
top_10_sections = section_counts.head(10).index.tolist()
print(f"Top 10 sections: {top_10_sections}")

import pandas as pd
import math

def create_classification_labels(df, top_sections):
    """Create multi-class classification for top 10 + 'other'"""
    df_copy = df.copy()
    df_copy['label'] = df_copy['section'].apply(
        lambda x: x if x in top_sections else 'other'
    )
    return df_copy

def smart_balanced_sampling(df, top_10_sections, target_total=120_000):
    """
    Balanced sampling using square-root scaled class proportions with per-class limits
    """
    df_labeled = create_classification_labels(df, top_10_sections)
    original_counts = df_labeled['label'].value_counts()
    total_original = len(df_labeled)

    sqrt_proportions = {}
    total_sqrt = 0

    for label, count in original_counts.items():
        prop = count / total_original if total_original > 0 else 0
        sqrt_prop = math.sqrt(prop)
        sqrt_proportions[label] = sqrt_prop
        total_sqrt += sqrt_prop

    sampled_dfs = []
    sampling_info = {}

    for label in original_counts.index:
        norm_sqrt_prop = sqrt_proportions[label] / total_sqrt if total_sqrt > 0 else 0
        target_samples = int(target_total * norm_sqrt_prop)

        min_samples = 3000   # allow better representation for rare classes
        max_samples = 15000  # avoid letting one class dominate

        available = original_counts[label]
        final_target = min(max(target_samples, min_samples), min(available, max_samples))

        label_df = df_labeled[df_labeled['label'] == label]
        sampled_df = label_df.sample(n=final_target, random_state=42)
        sampled_dfs.append(sampled_df)

        sampling_info[label] = {
            'original_count': available,
            'sampled_count': final_target,
            'sampling_ratio': round(final_target / available, 3) if available > 0 else 0
        }

    df_sampled = pd.concat(sampled_dfs, ignore_index=True)
    df_sampled = df_sampled.sample(frac=1, random_state=42).reset_index(drop=True)

    return df_sampled, sampling_info

# Usage
df_sampled, sampling_info = smart_balanced_sampling(df, top_10_sections, target_total=120_000)

# Output summary
print(f"Final dataset size: {len(df_sampled):,} samples")
print("Class distribution:")
final_counts = df_sampled['label'].value_counts()
for label, count in final_counts.items():
    pct = (count / len(df_sampled)) * 100
    print(f"  {label:15}: {count:6,} ({pct:5.1f}%)")

# Balance ratio
max_c = final_counts.max()
min_c = final_counts.min()
balance_ratio = max_c / min_c if min_c > 0 else float('inf')
print(f"Balance ratio: {balance_ratio:.1f}:1")

df_sampled.to_csv("smart_balanced_dataset.csv", index=False)
# Download the CSV for reproductibility

# Prepare data for training
label_encoder = LabelEncoder()
df_sampled['encoded_label'] = label_encoder.fit_transform(df_sampled['label'])

# Split into train/val/test (70/15/15)
from sklearn.model_selection import train_test_split

# First split: 70% train, 30% temp
train_df, temp_df = train_test_split(
    df_sampled, test_size=0.3, random_state=42, stratify=df_sampled['encoded_label']
)

# Second split: 15% validation, 15% test
val_df, test_df = train_test_split(
    temp_df, test_size=0.5, random_state=42, stratify=temp_df['encoded_label']
)

print(f"Train size: {len(train_df)}, Val size: {len(val_df)}, Test size: {len(test_df)}")

from transformers import AutoTokenizer, AutoModelForSequenceClassification
from datasets import Dataset

# Model checkpoint and number of classes
model_name = "distilbert-base-uncased"
num_labels = 11  # 10 most common sections + 'other'

# Load tokenizer and add pad token if missing
tokenizer = AutoTokenizer.from_pretrained(model_name)
if tokenizer.pad_token is None:
    tokenizer.add_special_tokens({'pad_token': '[PAD]'})

# Load model and resize embeddings if tokenizer was updated
model = AutoModelForSequenceClassification.from_pretrained(model_name, num_labels=num_labels)
model.resize_token_embeddings(len(tokenizer))  # Resize for added token

# Tokenization function
def tokenize_function(examples):
    texts = examples['text'] if isinstance(examples['text'], list) else [examples['text']]
    return tokenizer(
        texts,
        truncation=True,
        padding=False,  # Let the DataCollator handle padding
        max_length=512,
    )

# Convert to HuggingFace datasets
train_dataset = Dataset.from_pandas(train_df[['text', 'encoded_label']])
val_dataset = Dataset.from_pandas(val_df[['text', 'encoded_label']])  # Added validation set
test_dataset = Dataset.from_pandas(test_df[['text', 'encoded_label']])

# Tokenize datasets
train_dataset = train_dataset.map(tokenize_function, batched=True)
val_dataset = val_dataset.map(tokenize_function, batched=True)  # Added validation tokenization
test_dataset = test_dataset.map(tokenize_function, batched=True)

# Rename label column
train_dataset = train_dataset.rename_column('encoded_label', 'labels')
val_dataset = val_dataset.rename_column('encoded_label', 'labels')  # Added validation rename
test_dataset = test_dataset.rename_column('encoded_label', 'labels')

# Remove text column after tokenization
train_dataset = train_dataset.remove_columns(['text'])
val_dataset = val_dataset.remove_columns(['text'])  # Added validation cleanup
test_dataset = test_dataset.remove_columns(['text'])

# Remove the __index_level_0__ column if it exists (added by from_pandas)
if '__index_level_0__' in train_dataset.column_names:
    train_dataset = train_dataset.remove_columns(['__index_level_0__'])
if '__index_level_0__' in val_dataset.column_names:
    val_dataset = val_dataset.remove_columns(['__index_level_0__'])  # Added validation cleanup
if '__index_level_0__' in test_dataset.column_names:
    test_dataset = test_dataset.remove_columns(['__index_level_0__'])

print(f"Train dataset columns: {train_dataset.column_names}")
print(f"Val dataset columns: {val_dataset.column_names}")  # Added validation check
print(f"Test dataset columns: {test_dataset.column_names}")
print(f"Train dataset features: {train_dataset.features}")

"""
**SETTING UP TRAINING**"""

import pandas as pd
import numpy as np
import torch
from transformers import (
    AutoModelForSequenceClassification,
    TrainingArguments,
    Trainer,
    DataCollatorWithPadding,
    EarlyStoppingCallback,
    get_linear_schedule_with_warmup
)
from sklearn.metrics import (
    accuracy_score,
    precision_recall_fscore_support,
    classification_report,
    confusion_matrix
)
from sklearn.preprocessing import LabelEncoder
import torch.nn.functional as F
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
import os
from datetime import datetime
import json

# Suppress warnings for cleaner output
warnings.filterwarnings('ignore')

def set_seed(seed=42):
    """Set all random seeds for reproducibility"""
    torch.manual_seed(seed)
    torch.cuda.manual_seed_all(seed)
    np.random.seed(seed)
    torch.backends.cudnn.deterministic = True
    torch.backends.cudnn.benchmark = False

set_seed(42)

def setup_classification_labels(df, n_top=10):
    """
    Enhanced setup with better validation and statistics
    """
    print("🏷️  SETTING UP CLASSIFICATION LABELS")
    print("=" * 60)

    # Validate input
    if 'section' not in df.columns:
        raise ValueError("DataFrame must contain 'section' column")

    # Get top sections by frequency
    section_counts = df['section'].value_counts()
    top_sections = section_counts.head(n_top).index.tolist()

    print(f"Dataset Overview:")
    print(f"  Total samples: {len(df):,}")
    print(f"  Unique sections: {len(section_counts):,}")
    print(f"  Selected top {n_top} sections + 'other'")

    print(f"\nTop {n_top} sections by frequency:")
    cumulative_samples = 0
    for i, (section, count) in enumerate(section_counts.head(n_top).items(), 1):
        pct = (count / len(df)) * 100
        cumulative_samples += count
        print(f"{i:2d}. {section[:30]:<30}: {count:6,} ({pct:5.1f}%)")

    # Calculate "other" category
    other_count = len(df) - cumulative_samples
    other_pct = (other_count / len(df)) * 100
    print(f"{'Other sections combined'[:30]:<30}: {other_count:6,} ({other_pct:5.1f}%)")

    # Create labels
    df_labeled = df.copy()
    df_labeled['label'] = df_labeled['section'].apply(
        lambda x: x if x in top_sections else 'other'
    )

    # Create and fit label encoder
    label_encoder = LabelEncoder()
    df_labeled['label_encoded'] = label_encoder.fit_transform(df_labeled['label'])

    # Final distribution
    print(f"\nFinal classification distribution:")
    final_counts = df_labeled['label'].value_counts()
    print("-" * 60)
    for i, (label, count) in enumerate(final_counts.items()):
        pct = (count / len(df_labeled)) * 100
        encoded_label = label_encoder.transform([label])[0]
        print(f"{encoded_label:2d}. {label[:25]:<25}: {count:6,} ({pct:5.1f}%)")

    # Balance analysis
    max_count = final_counts.max()
    min_count = final_counts.min()
    balance_ratio = max_count / min_count
    print(f"\nClass Balance Analysis:")
    print(f"  Most frequent class: {max_count:,} samples")
    print(f"  Least frequent class: {min_count:,} samples")
    print(f"  Balance ratio: {balance_ratio:.1f}:1")

    if balance_ratio > 10:
        print("  ⚠️  High class imbalance detected - consider class weights")
    elif balance_ratio > 5:
        print("  ⚠️  Moderate class imbalance - monitor per-class performance")
    else:
        print("  ✅ Good class balance")

    return df_labeled, label_encoder, top_sections

def compute_comprehensive_metrics(eval_pred, class_weights=None):
    """
    Enhanced metrics computation with class weight support
    """
    predictions, labels = eval_pred

    # Convert to numpy if needed
    if isinstance(predictions, torch.Tensor):
        predictions = predictions.cpu().numpy()
    if isinstance(labels, torch.Tensor):
        labels = labels.cpu().numpy()

    # Get probabilities and predictions
    probabilities = F.softmax(torch.tensor(predictions), dim=-1).numpy()
    predicted_labels = np.argmax(predictions, axis=1)

    # Calculate metrics
    accuracy = accuracy_score(labels, predicted_labels)

    # Weighted metrics (handles class imbalance better)
    precision, recall, f1, _ = precision_recall_fscore_support(
        labels, predicted_labels, average='weighted', zero_division=0
    )

    # Macro metrics (equal weight to all classes)
    macro_precision, macro_recall, macro_f1, _ = precision_recall_fscore_support(
        labels, predicted_labels, average='macro', zero_division=0
    )

    # Confidence metrics
    mean_confidence = np.mean(np.max(probabilities, axis=1))
    prediction_entropy = -np.mean(np.sum(probabilities * np.log(probabilities + 1e-8), axis=1))

    return {
        'accuracy': accuracy,
        'f1_weighted': f1,
        'f1_macro': macro_f1,
        'precision_weighted': precision,
        'recall_weighted': recall,
        'precision_macro': macro_precision,
        'recall_macro': macro_recall,
        'mean_confidence': mean_confidence,
        'prediction_entropy': prediction_entropy
    }

def predict_with_probabilities(trainer, dataset, label_encoder, batch_size=64):
    """
    Enhanced prediction with better memory management and error handling
    """
    print("🔮 GENERATING PREDICTIONS WITH PROBABILITIES")
    print("=" * 60)

    try:
        # Get predictions in batches to manage memory
        predictions = trainer.predict(dataset)
        logits = predictions.predictions
        true_labels = predictions.label_ids

        # Convert to probabilities
        probabilities = F.softmax(torch.tensor(logits), dim=-1).numpy()
        predicted_labels = np.argmax(logits, axis=1)

        # Create comprehensive results
        results_df = pd.DataFrame({
            'true_label_encoded': true_labels,
            'predicted_label_encoded': predicted_labels,
            'true_label': label_encoder.inverse_transform(true_labels),
            'predicted_label': label_encoder.inverse_transform(predicted_labels),
            'max_probability': np.max(probabilities, axis=1),
            'correct_prediction': (true_labels == predicted_labels)
        })

        # Add probability columns for each class
        for i, class_name in enumerate(label_encoder.classes_):
            results_df[f'prob_{class_name}'] = probabilities[:, i]

        # Add confidence metrics
        results_df['prediction_entropy'] = -np.sum(
            probabilities * np.log(probabilities + 1e-8), axis=1
        )

        # Summary statistics
        accuracy = accuracy_score(true_labels, predicted_labels)
        avg_confidence = results_df['max_probability'].mean()

        print(f"✅ Predictions completed successfully")
        print(f"   Samples processed: {len(results_df):,}")
        print(f"   Accuracy: {accuracy:.3f}")
        print(f"   Average confidence: {avg_confidence:.3f}")

        return results_df, probabilities, predicted_labels, true_labels

    except Exception as e:
        print(f"❌ Error during prediction: {str(e)}")
        raise

def generate_comprehensive_reports(y_true, y_pred, y_proba, label_encoder,
                                 dataset_name="Dataset", save_plots=True):
    """
    Generate comprehensive reports with visualizations
    """
    print(f"\n📊 CLASSIFICATION REPORT - {dataset_name.upper()}")
    print("=" * 80)

    class_names = label_encoder.classes_

    # Standard classification report
    report = classification_report(
        y_true, y_pred, target_names=class_names, digits=3, zero_division=0
    )
    print(report)

    # Confusion matrix
    cm = confusion_matrix(y_true, y_pred)

    if save_plots:
        # Plot confusion matrix
        plt.figure(figsize=(12, 10))
        sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
                   xticklabels=class_names, yticklabels=class_names)
        plt.title(f'Confusion Matrix - {dataset_name}')
        plt.xlabel('Predicted')
        plt.ylabel('Actual')
        plt.xticks(rotation=45)
        plt.yticks(rotation=0)
        plt.tight_layout()
        plt.savefig(f'confusion_matrix_{dataset_name.lower()}.png', dpi=300, bbox_inches='tight')
        plt.show()

    # Per-class metrics with probabilities
    precision, recall, f1, support = precision_recall_fscore_support(
        y_true, y_pred, average=None, zero_division=0
    )

    print(f"\n📈 DETAILED PER-CLASS ANALYSIS - {dataset_name.upper()}")
    print("-" * 80)
    print(f"{'Class':<20} {'Precision':<10} {'Recall':<10} {'F1-Score':<10} {'Support':<10} {'Avg_Prob':<10}")
    print("-" * 80)

    class_metrics = []
    for i, class_name in enumerate(class_names):
        class_mask = (y_true == i)
        avg_prob = y_proba[class_mask, i].mean() if class_mask.sum() > 0 else 0

        print(f"{class_name[:19]:<20} {precision[i]:<10.3f} {recall[i]:<10.3f} "
              f"{f1[i]:<10.3f} {support[i]:<10} {avg_prob:<10.3f}")

        class_metrics.append({
            'class': class_name,
            'precision': precision[i],
            'recall': recall[i],
            'f1': f1[i],
            'support': support[i],
            'avg_prob': avg_prob
        })

    # Overall metrics
    accuracy = accuracy_score(y_true, y_pred)
    macro_f1 = f1.mean()
    weighted_f1 = np.average(f1, weights=support)

    print("-" * 80)
    print(f"{'Overall Accuracy':<30}: {accuracy:.3f}")
    print(f"{'Macro Avg F1':<30}: {macro_f1:.3f}")
    print(f"{'Weighted Avg F1':<30}: {weighted_f1:.3f}")

    return {
        'accuracy': accuracy,
        'macro_f1': macro_f1,
        'weighted_f1': weighted_f1,
        'per_class_metrics': class_metrics,
        'confusion_matrix': cm,
        'classification_report': report
    }

def analyze_prediction_probabilities(results_df, label_encoder, save_plots=True):
    """
    Enhanced probability analysis with visualizations
    """
    print(f"\n🎯 PROBABILITY ANALYSIS")
    print("=" * 60)

    # Basic confidence statistics
    conf_stats = results_df['max_probability'].describe()
    print(f"Prediction Confidence Statistics:")
    for stat, value in conf_stats.items():
        print(f"  {stat.capitalize()}: {value:.3f}")

    # Confidence by correctness
    correct_conf = results_df[results_df['correct_prediction']]['max_probability']
    incorrect_conf = results_df[~results_df['correct_prediction']]['max_probability']

    print(f"\nConfidence by Prediction Correctness:")
    print(f"  Correct predictions:   {correct_conf.mean():.3f} ± {correct_conf.std():.3f}")
    print(f"  Incorrect predictions: {incorrect_conf.mean():.3f} ± {incorrect_conf.std():.3f}")

    # Confidence thresholds analysis
    thresholds = [0.5, 0.7, 0.9]
    print(f"\nConfidence Threshold Analysis:")
    for threshold in thresholds:
        high_conf = results_df[results_df['max_probability'] >= threshold]
        if len(high_conf) > 0:
            accuracy_at_threshold = high_conf['correct_prediction'].mean()
            coverage = len(high_conf) / len(results_df)
            print(f"  Confidence ≥ {threshold}: {len(high_conf):,} samples ({coverage:.1%}) "
                  f"- Accuracy: {accuracy_at_threshold:.3f}")

    if save_plots:
        # Plot confidence distributions
        fig, axes = plt.subplots(2, 2, figsize=(15, 10))

        # Confidence distribution
        axes[0, 0].hist(results_df['max_probability'], bins=50, alpha=0.7, edgecolor='black')
        axes[0, 0].set_title('Distribution of Prediction Confidence')
        axes[0, 0].set_xlabel('Max Probability')
        axes[0, 0].set_ylabel('Frequency')
        axes[0, 0].axvline(results_df['max_probability'].mean(), color='red', linestyle='--',
                          label=f'Mean: {results_df["max_probability"].mean():.3f}')
        axes[0, 0].legend()

        # Confidence by correctness
        axes[0, 1].hist(correct_conf, bins=30, alpha=0.7, label='Correct', color='green')
        axes[0, 1].hist(incorrect_conf, bins=30, alpha=0.7, label='Incorrect', color='red')
        axes[0, 1].set_title('Confidence by Prediction Correctness')
        axes[0, 1].set_xlabel('Max Probability')
        axes[0, 1].set_ylabel('Frequency')
        axes[0, 1].legend()

        # Entropy distribution
        axes[1, 0].hist(results_df['prediction_entropy'], bins=50, alpha=0.7, edgecolor='black')
        axes[1, 0].set_title('Distribution of Prediction Entropy')
        axes[1, 0].set_xlabel('Entropy')
        axes[1, 0].set_ylabel('Frequency')

        # Accuracy vs confidence
        conf_bins = np.linspace(0, 1, 21)
        accuracies = []
        bin_centers = []
        for i in range(len(conf_bins)-1):
            mask = (results_df['max_probability'] >= conf_bins[i]) & \
                   (results_df['max_probability'] < conf_bins[i+1])
            if mask.sum() > 0:
                accuracies.append(results_df[mask]['correct_prediction'].mean())
                bin_centers.append((conf_bins[i] + conf_bins[i+1]) / 2)

        axes[1, 1].plot(bin_centers, accuracies, 'o-', linewidth=2, markersize=6)
        axes[1, 1].set_title('Accuracy vs Confidence')
        axes[1, 1].set_xlabel('Confidence Bin')
        axes[1, 1].set_ylabel('Accuracy')
        axes[1, 1].grid(True, alpha=0.3)

        plt.tight_layout()
        plt.savefig('probability_analysis.png', dpi=300, bbox_inches='tight')
        plt.show()

def complete_enhanced_pipeline(df, train_dataset, val_dataset, test_dataset,
                             tokenizer, model_name, n_top=10,
                             use_class_weights=False, save_model=True):
    """
    Complete enhanced pipeline with all improvements
    """
    print("🚀 ENHANCED CLASSIFICATION PIPELINE")
    print("=" * 80)

    # Create output directory
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_dir = f'./classification_results_{timestamp}'
    os.makedirs(output_dir, exist_ok=True)

    # Setup labels
    df_labeled, label_encoder, top_sections = setup_classification_labels(df, n_top)

    # Calculate class weights if requested
    class_weights = None
    if use_class_weights:
        from sklearn.utils.class_weight import compute_class_weight
        class_weights = compute_class_weight(
            'balanced', classes=np.unique(df_labeled['label_encoded']),
            y=df_labeled['label_encoded']
        )
        print(f"📊 Using class weights: {dict(zip(range(len(class_weights)), class_weights))}")

    # Load model with DistilBERT configuration
    num_labels = len(label_encoder.classes_)
    model = AutoModelForSequenceClassification.from_pretrained(
        model_name,
        num_labels=num_labels,
        problem_type="single_label_classification",
        dropout=0.1,
        attention_dropout=0.1
    )

    # Enhanced training arguments
    training_args = TrainingArguments(
        output_dir=output_dir,
        num_train_epochs=5,
        per_device_train_batch_size=16,
        per_device_eval_batch_size=32,
        gradient_accumulation_steps=2,
        learning_rate=2e-5,
        weight_decay=0.01,
        warmup_ratio=0.1,
        lr_scheduler_type="cosine",
        eval_strategy="steps",
        eval_steps=100,
        save_strategy="steps",
        save_steps=100,
        save_total_limit=2,
        load_best_model_at_end=True,
        metric_for_best_model="eval_f1_weighted",
        greater_is_better=True,
        logging_steps=25,
        logging_dir=f"{output_dir}/logs",
        gradient_checkpointing=True,
        fp16=True,
        dataloader_pin_memory=False,
        report_to=None,
        seed=42,
        data_seed=42,
        remove_unused_columns=True,
        group_by_length=True,
        prediction_loss_only=False,
        push_to_hub=False,
        resume_from_checkpoint=None,
        ignore_data_skip=False,
    )

    # Enhanced data collator
    data_collator = DataCollatorWithPadding(
        tokenizer=tokenizer,
        return_tensors="pt",
        padding=True
    )

    # Initialize enhanced trainer
    trainer = Trainer(
        model=model,
        args=training_args,
        train_dataset=train_dataset,
        eval_dataset=val_dataset,
        tokenizer=tokenizer,
        data_collator=data_collator,
        compute_metrics=lambda x: compute_comprehensive_metrics(x, class_weights),
        callbacks=[
            EarlyStoppingCallback(early_stopping_patience=3, early_stopping_threshold=0.001)
        ]
    )

    # Train with better logging
    print("\n🎯 STARTING TRAINING...")
    print("-" * 60)

    try:
        trainer.train()
        print("✅ Training completed successfully!")
    except Exception as e:
        print(f"❌ Training failed: {str(e)}")
        raise

    # Save training history
    history_df = pd.DataFrame(trainer.state.log_history)
    history_df.to_csv(f'{output_dir}/training_history.csv', index=False)

    # Comprehensive evaluation
    print("\n📊 COMPREHENSIVE EVALUATION")
    print("=" * 60)

    # Training set evaluation
    train_results, train_proba, train_pred, train_true = predict_with_probabilities(
        trainer, train_dataset, label_encoder
    )
    train_metrics = generate_comprehensive_reports(
        train_true, train_pred, train_proba, label_encoder, "TRAINING"
    )

    # Test set evaluation
    test_results, test_proba, test_pred, test_true = predict_with_probabilities(
        trainer, test_dataset, label_encoder
    )
    test_metrics = generate_comprehensive_reports(
        test_true, test_pred, test_proba, label_encoder, "TEST"
    )

    # Probability analysis
    analyze_prediction_probabilities(test_results, label_encoder)

    # Save all results
    train_results.to_csv(f'{output_dir}/train_predictions_detailed.csv', index=False)
    test_results.to_csv(f'{output_dir}/test_predictions_detailed.csv', index=False)

    # Save model and tokenizer
    if save_model:
        model.save_pretrained(f'{output_dir}/model')
        tokenizer.save_pretrained(f'{output_dir}/tokenizer')

        # Save label encoder
        import joblib
        joblib.dump(label_encoder, f'{output_dir}/label_encoder.pkl')

    # Save configuration
    config = {
        'model_name': model_name,
        'n_top_sections': n_top,
        'num_labels': num_labels,
        'top_sections': top_sections,
        'class_names': label_encoder.classes_.tolist(),
        'training_args': training_args.to_dict(),
        'train_samples': len(train_dataset),
        'val_samples': len(val_dataset),
        'test_samples': len(test_dataset),
        'timestamp': timestamp
    }

    with open(f'{output_dir}/config.json', 'w') as f:
        json.dump(config, f, indent=2)

    # Final summary
    print(f"\n🎉 PIPELINE COMPLETED SUCCESSFULLY")
    print("=" * 80)
    print(f"✅ Model trained and saved to: {output_dir}")
    print(f"✅ All results saved with timestamp: {timestamp}")
    print(f"✅ Test accuracy: {test_metrics['accuracy']:.3f}")
    print(f"✅ Test F1 (weighted): {test_metrics['weighted_f1']:.3f}")
    print(f"✅ Test F1 (macro): {test_metrics['macro_f1']:.3f}")

    return {
        'trainer': trainer,
        'label_encoder': label_encoder,
        'train_results': train_results,
        'test_results': test_results,
        'train_metrics': train_metrics,
        'test_metrics': test_metrics,
        'top_sections': top_sections,
        'output_dir': output_dir,
        'config': config
    }

"""**Run the training and evaluation scripts**"""

# Run the enhanced pipeline
results = complete_enhanced_pipeline(
    df=df_sampled,
    train_dataset=train_dataset,
    val_dataset=val_dataset,
    test_dataset=test_dataset,
    tokenizer=tokenizer,
    model_name="distilbert-base-uncased",
    n_top=10,
    use_class_weights=True,  # For handling class imbalance
    save_model=True
)

# Save model & tokenizer to use on other sessions without re-training
# Access the trainer object from the results dictionary returned by the pipeline
trainer_instance = results['trainer']
trainer_instance.save_model("./classification_model")
tokenizer.save_pretrained("./classification_model")

# Save label encoder
import pickle
label_encoder_instance = results['label_encoder']
with open("./classification_model/label_encoder.pkl", "wb") as f:
    pickle.dump(label_encoder_instance, f)

!zip -r classification_model.zip ./classification_model

# Example on how to load it on other sessions (I tested it on VSCode, it works :D)

'''
from transformers import AutoModelForSequenceClassification, AutoTokenizer
import pickle

# Load tokenizer
tokenizer = AutoTokenizer.from_pretrained("./classification_model")

# Load model
model = AutoModelForSequenceClassification.from_pretrained("./classification_model")

# Load label encoder
with open("./classification_model/label_encoder.pkl", "rb") as f:
    label_encoder = pickle.load(f)

'''

"""**2. Integrate as DocumentClassification component in Haystack**"""

from haystack import Document, Pipeline
from haystack.components.writers import DocumentWriter
from haystack.document_stores.in_memory import InMemoryDocumentStore
from haystack.components.retrievers.in_memory import InMemoryBM25Retriever
from haystack.components.builders import PromptBuilder
from typing import List, Dict, Any
import logging

"""**3. Create a Pipeline to classify custom-created documents into section**

**This test mixes 5 real documents from the smart-balanced dataset and 10 manually written custom documents. It shows:**

1. Predicted vs. true labels for real docs

2. Generalization results on unseen custom text

3. Confidence scores + top 3 section predictions

Useful for evaluating both model accuracy and real-world performance.

"""

from transformers import AutoConfig

config = AutoConfig.from_pretrained('./classification_model')
print("id2label:", config.id2label)
print("label2id:", config.label2id)

# Check the training data
print("Unique labels in training data:", sorted(train_df['label'].unique()))
print("Encoded labels:", sorted(train_df['encoded_label'].unique()))

# See the mapping
for label in sorted(train_df['label'].unique()):
    encoded = train_df[train_df['label'] == label]['encoded_label'].iloc[0]
    print(f"'{label}' -> {encoded}")

""">Label Mapping

- Label mappings based on actual training data encoding
- During preprocessing, string labels were converted to numeric indices using LabelEncoder
- which sorts alphabetically: Applications(0), Definition(1), Description(2), etc.
- This mapping aligns with how the model was actually trained
"""

import torch
import pickle
import pandas as pd
from typing import List, Dict, Any
from transformers import AutoModelForSequenceClassification, AutoTokenizer
from haystack import Document

# === 1. Optimized Classification Component ===
class DocumentClassificationComponent:
    def __init__(self, model_path: str, top_k: int = 5):
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

        # Load model and tokenizer
        self.model = AutoModelForSequenceClassification.from_pretrained(model_path)
        self.tokenizer = AutoTokenizer.from_pretrained(model_path)

        # Fix pad token if needed
        if self.tokenizer.pad_token is None:
            self.tokenizer.add_special_tokens({'pad_token': '[PAD]'})
            self.model.resize_token_embeddings(len(self.tokenizer))

        self.model.to(self.device)
        self.model.eval()

        # Load label encoder
        with open(f'{model_path}/label_encoder.pkl', 'rb') as f:
            self.label_encoder = pickle.load(f)

        self.top_k = top_k

    def run(self, documents: List[Document]) -> Dict[str, Any]:
        contents = [doc.content for doc in documents]
        inputs = self.tokenizer(
            contents,
            truncation=True,
            padding=True,
            max_length=512,
            return_tensors="pt"
        )
        inputs = {k: v.to(self.device) for k, v in inputs.items()}

        with torch.no_grad():
            outputs = self.model(**inputs)
            probabilities = torch.softmax(outputs.logits, dim=1)
            predicted_class_ids = torch.argmax(probabilities, dim=1)

        classified_docs = []
        for i, doc in enumerate(documents):
            class_id = predicted_class_ids[i].item()
            confidence = probabilities[i][class_id].item()
            predicted_class = self.label_encoder.inverse_transform([class_id])[0]

            # Top-k
            top_probs, top_indices = torch.topk(probabilities[i], min(self.top_k, len(self.label_encoder.classes_)))
            top_classes = self.label_encoder.inverse_transform(top_indices.cpu().numpy())
            top_predictions = list(zip(top_classes, top_probs.cpu().tolist()))

            new_doc = Document(
                content=doc.content,
                meta={
                    **doc.meta,
                    "predicted_section": predicted_class,
                    "classification_confidence": confidence,
                    "top_predictions": top_predictions
                }
            )
            classified_docs.append(new_doc)

        return {"documents": classified_docs}


# === 2. Initialize the classifier ===
classifier = DocumentClassificationComponent('./classification_model')


# === 3. Load real test documents from dataset ===
df_sampled = pd.read_csv("smart_balanced_dataset.csv")

real_rows = df_sampled.sample(n=5, random_state=42)

real_docs = [
    Document(
        content=row["text"],
        meta={
            "true_label": row["label"],
            "title": row.get("title", ""),
            "section": row.get("section", ""),
            "source": f"real_doc_{i+1}"
        }
    )
    for i, (_, row) in enumerate(real_rows.iterrows())
]


# === 4. Create custom documents for inference ===
custom_texts = [
    "The American Civil War was fought from 1861 to 1865 between the Union and Confederate states.",
    "Machine learning algorithms use statistical techniques to enable computers to learn from data without explicit programming.",
    "The human circulatory system consists of the heart, blood vessels, and blood that transport nutrients throughout the body.",
    "William Shakespeare wrote many famous plays including Romeo and Juliet, Hamlet, and Macbeth during the Elizabethan era.",
    "Photosynthesis is the process by which plants convert sunlight, carbon dioxide, and water into glucose and oxygen.",
    "The theory of relativity, developed by Albert Einstein, revolutionized our understanding of space, time, and gravity.",
    "Ancient Rome was one of the most powerful civilizations, lasting from 753 BC to 476 AD with significant cultural impact.",
    "Artificial neural networks are computing systems inspired by biological neural networks that learn to perform tasks.",
    "The periodic table organizes chemical elements by atomic number and shows recurring patterns in element properties.",
    "World War II lasted from 1939 to 1945 and involved most of the world's nations in the deadliest conflict in history."
]

custom_docs = [
    Document(
        content=text,
        meta={"source": f"custom_doc_{i+1}"}
    )
    for i, text in enumerate(custom_texts)
]


# === 5. Run classification ===
all_docs = real_docs + custom_docs
results = classifier.run(all_docs)
classified_docs = results["documents"]


# === 6. Print results ===
print(" Classification Results (Real + Custom Documents):")
print("=" * 80)
for doc in classified_docs:
    is_real = "true_label" in doc.meta
    print(f" Source: {doc.meta.get('source', 'unknown')}")
    if doc.meta.get('title'):
        print(f" Title: {doc.meta.get('title')}")
    print(f" Text Preview: {doc.content[:100]}...")

    if is_real:
        print(f"✅ True Label: {doc.meta['true_label']}")

    print(f" Predicted Section: {doc.meta.get('predicted_section', 'N/A')}")
    print(f" Confidence: {doc.meta.get('classification_confidence', 0):.3f}")
    print(f" Top 3 Predictions: {doc.meta.get('top_predictions', [])[:3]}")
    print("-" * 80)

ls classification_model

"""**4. Create QA Pipeline for History section + Logging  non history queries**

- This creates a "non_history_questions.json" which logs predicted non-history questions

Using the trained LLM Model without Keyword Fallbacks
"""

"""
Haystack v2.15.1 History QA Pipeline
Uses smart_balanced_dataset.csv with columns: title, section, text, label
"""

import json
import pandas as pd
from datetime import datetime
from typing import Dict, List, Any
from pathlib import Path

# Haystack v2 imports
from haystack import Pipeline, component, Document
from haystack.components.retrievers import InMemoryBM25Retriever
from haystack.document_stores.in_memory import InMemoryDocumentStore
try:
    import torch
    import torch.nn.functional as F
    from transformers import AutoModelForSequenceClassification, AutoTokenizer
    ML_AVAILABLE = True
except ImportError:
    ML_AVAILABLE = False


class DocumentClassificationComponent:
    """ML-based document classification component"""

    def __init__(self, model_path: str):
        if not ML_AVAILABLE:
            raise ImportError("ML dependencies not available. Install torch and transformers.")

        self.model = AutoModelForSequenceClassification.from_pretrained(model_path)
        self.tokenizer = AutoTokenizer.from_pretrained(model_path)
        self.model.eval()

        # CORRECT label mappings based on the actual training data
        self.model.config.id2label = {
            0: "Applications",
            1: "Definition",
            2: "Description",
            3: "Diagnosis",
            4: "Examples",
            5: "Function",
            6: "History",      # <- This is twhat we care about
            7: "Overview",
            8: "Structure",
            9: "Types",
            10: "other"
        }
        self.model.config.label2id = {v: k for k, v in self.model.config.id2label.items()}
        self.id2label = self.model.config.id2label

    def predict(self, title: str = "", text: str = "") -> tuple:
        """Predict if content is history-related"""
        input_text = f"{title} {text}".strip()

        try:
            inputs = self.tokenizer(input_text, return_tensors="pt", truncation=True, max_length=512)
            with torch.no_grad():
                outputs = self.model(**inputs)
                probs = F.softmax(outputs.logits, dim=-1)
                pred_id = torch.argmax(probs, dim=-1).item()
                confidence = probs[0, pred_id].item()
                label = self.id2label[pred_id]

            # Check if it's the "History" section (ID 6)
            is_history = (label == "History" and confidence > 0.6)

            if not is_history and confidence < 0.5:
                return self._keyword_fallback(input_text)

            return is_history, confidence, label

        except Exception as e:
            print(f"ML prediction error: {e}")
            return self._keyword_fallback(input_text)

    def _keyword_fallback(self, text: str) -> tuple:
        """Fallback keyword-based classification"""
        history_keywords = ['war', 'revolution', 'ancient', 'empire', 'dynasty',
                           'treaty', 'colonial', 'independence', 'century', 'battle']
        is_history = any(keyword in text.lower() for keyword in history_keywords)
        return is_history, 0.0, "keyword_fallback"


@component
class HistoryQuestionFilter:
    """Filter component for history-related queries"""

    def __init__(self, model_path: str = './classification_model', use_ml: bool = True):
        self.use_ml = use_ml and ML_AVAILABLE
        if self.use_ml:
            try:
                self.classifier = DocumentClassificationComponent(model_path)
            except Exception as e:
                print(f"Failed to load ML model: {e}. Using keyword fallback.")
                self.use_ml = False

    @component.output_types(
        query=str,
        is_history_question=bool,
        filtered_reason=str,
        confidence=float
    )
    def run(self, query: str) -> Dict[str, Any]:
        """Filter queries for history content"""
        if self.use_ml:
            is_history, confidence, prediction = self.classifier.predict(text=query)
            reason = f"ML classified as {prediction} (confidence: {confidence:.3f})"
        else:
            is_history, confidence, prediction = self.classifier._keyword_fallback(query) if hasattr(self, 'classifier') else self._simple_keyword_check(query)
            reason = f"Keyword-based classification: {prediction}"

        return {
            "query": query,
            "is_history_question": is_history,
            "filtered_reason": reason,
            "confidence": confidence
        }

    def _simple_keyword_check(self, query: str) -> tuple:
        """Simple keyword check when ML is not available"""
        history_keywords = ['war', 'revolution', 'ancient', 'empire', 'dynasty',
                           'treaty', 'colonial', 'independence', 'century', 'battle']
        is_history = any(keyword in query.lower() for keyword in history_keywords)
        return is_history, 0.0, "history" if is_history else "non-history"


@component
class ConditionalRouter:
    """Routes queries based on history classification"""

    @component.output_types(
        history_query=str,
        non_history_query=str,
        filtered_reason=str,
        confidence=float
    )
    def run(self, query: str, is_history_question: bool, filtered_reason: str, confidence: float = 0.0) -> Dict[str, Any]:
        """Route based on history classification"""
        if is_history_question:
            return {
                "history_query": query,
                "filtered_reason": filtered_reason,
                "confidence": confidence
            }
        else:
            return {
                "non_history_query": query,
                "filtered_reason": filtered_reason,
                "confidence": confidence
            }


@component
class NonHistoryLogger:
    """Logs non-history questions"""

    def __init__(self, log_file: str = "non_history_questions.json"):
        self.log_file = Path(log_file)

    @component.output_types(
        logged_query=str,
        log_message=str
    )
    def run(self, non_history_query: str, filtered_reason: str, confidence: float = 0.0) -> Dict[str, Any]:
        """Log non-history questions"""
        log_entry = {
            "question": non_history_query,
            "reason": filtered_reason,
            "confidence": confidence,
            "timestamp": datetime.now().isoformat()
        }

        # Load existing logs
        existing_logs = []
        if self.log_file.exists():
            try:
                with open(self.log_file, 'r') as f:
                    existing_logs = json.load(f)
            except (json.JSONDecodeError, FileNotFoundError):
                existing_logs = []

        # Append and save
        existing_logs.append(log_entry)
        with open(self.log_file, 'w') as f:
            json.dump(existing_logs, f, indent=2)

        return {
            "logged_query": non_history_query,
            "log_message": f"Non-history question logged: {non_history_query}"
        }


@component
class SimpleHistoryReader:
    """Generates answers from retrieved history documents"""

    @component.output_types(
        answer=str,
        documents=List[Document]
    )
    def run(self, documents: List[Document], query: str) -> Dict[str, Any]:
        """Generate answer from documents"""
        if not documents:
            return {
                "answer": "No relevant historical information found for your question.",
                "documents": []
            }

        # Create answer from top 3 documents
        context_parts = []
        for doc in documents[:3]:
            content = doc.content[:300] + "..." if len(doc.content) > 300 else doc.content
            title = doc.meta.get('title', 'Unknown')
            context_parts.append(f"From '{title}': {content}")

        context = "\n\n".join(context_parts)
        answer = f"Based on historical records:\n\n{context}"

        return {
            "answer": answer,
            "documents": documents
        }


def load_dataset(csv_path: str = "smart_balanced_dataset.csv", section_filter: str = "History", limit: int = 1000) -> List[Document]:
    """Load documents from CSV with columns: title, section, text, label"""

    if not Path(csv_path).exists():
        raise FileNotFoundError(f"CSV file not found: {csv_path}")

    print(f"Loading dataset from {csv_path}...")
    df = pd.read_csv(csv_path)

    # Verify required columns
    required_columns = ['title', 'section', 'text', 'label']
    missing_columns = [col for col in required_columns if col not in df.columns]
    if missing_columns:
        raise ValueError(f"Missing required columns: {missing_columns}")

    print(f"Dataset loaded with {len(df)} total records")
    print(f"Available sections: {df['section'].value_counts().to_dict()}")

    # Filter by section
    filtered_df = df[df['section'] == section_filter].head(limit)
    print(f"Filtered to {len(filtered_df)} {section_filter} documents")

    if len(filtered_df) == 0:
        raise ValueError(f"No documents found for section '{section_filter}'")

    # Convert to Haystack Documents
    documents = []
    for idx, row in filtered_df.iterrows():
        if pd.isna(row['text']) or not str(row['text']).strip():
            continue

        doc = Document(
            content=str(row['text']),
            meta={
                'title': str(row['title']),
                'section': str(row['section']),
                'label': str(row['label']),
                'doc_id': str(idx)
            }
        )
        documents.append(doc)

    print(f"Successfully created {len(documents)} documents")
    return documents


def build_pipeline(csv_path: str = "smart_balanced_dataset.csv",
                  section_filter: str = "History",
                  limit: int = 1000,
                  model_path: str = './classification_model',
                  use_ml: bool = True) -> Pipeline:
    """Build the complete History QA pipeline"""

    # Initialize document store
    document_store = InMemoryDocumentStore()

    # Load and store documents
    documents = load_dataset(csv_path, section_filter, limit)
    document_store.write_documents(documents)
    print(f"Document store initialized with {document_store.count_documents()} documents")

    # Initialize components
    history_filter = HistoryQuestionFilter(model_path=model_path, use_ml=use_ml)
    router = ConditionalRouter()
    retriever = InMemoryBM25Retriever(document_store)
    reader = SimpleHistoryReader()
    logger = NonHistoryLogger()

    # Build pipeline
    pipeline = Pipeline()
    pipeline.add_component("history_filter", history_filter)
    pipeline.add_component("router", router)
    pipeline.add_component("retriever", retriever)
    pipeline.add_component("reader", reader)
    pipeline.add_component("logger", logger)

    # Connect components
    pipeline.connect("history_filter.query", "router.query")
    pipeline.connect("history_filter.is_history_question", "router.is_history_question")
    pipeline.connect("history_filter.filtered_reason", "router.filtered_reason")
    pipeline.connect("history_filter.confidence", "router.confidence")

    # History path
    pipeline.connect("router.history_query", "retriever.query")
    pipeline.connect("retriever.documents", "reader.documents")
    pipeline.connect("router.history_query", "reader.query")

    # Non-history path
    pipeline.connect("router.non_history_query", "logger.non_history_query")
    pipeline.connect("router.filtered_reason", "logger.filtered_reason")
    pipeline.connect("router.confidence", "logger.confidence")

    return pipeline


def test_pipeline():
    """Test the pipeline with sample questions"""

    try:
        pipeline = build_pipeline()
    except Exception as e:
        print(f"Error building pipeline: {e}")
        return


    # The first 4 questions were taken from the smart_balanced.csv dataset so the answers should also be aligned.
    test_questions = [
        "When were the long-forgotten manuscripts of Tironian notes rediscovered?",
        "In what year did Guang H. Lin reported resonant light absorption by a fabricated nanostructure and rectification of light with frequencies in the visible range.?",
        "What hardware can a software-defined radio use for signal processing?",
        "Angband (1990) was developed by?",
        "What percentage of ectopic pregnancies implant in the ampullary section?",
        "How do male and female frogs differ in their response to advertisement calls?",
        "What is the connection between Loki and Beowulf?",
        "Explain the Linguistic Linear Unit"
    ]

    print("\n" + "="*80)
    print("TESTING HISTORY QA PIPELINE")
    print("="*80)

    for i, question in enumerate(test_questions, 1):
        print(f"\n{i}. Question: {question}")
        print("-" * 60)

        try:
            result = pipeline.run({"history_filter": {"query": question}})

            if "reader" in result and "answer" in result["reader"]:
                # History question
                answer = result["reader"]["answer"]
                documents = result["reader"]["documents"]
                print(f"✅ HISTORY QUESTION")
                print(f"Answer: {answer[:200]}...")
                print(f"Retrieved {len(documents)} documents")

                if documents:
                    print(f"Top document: {documents[0].meta.get('title', 'Unknown')}")

            elif "logger" in result:
                # Non-history question
                print(f"❌ NON-HISTORY QUESTION")
                print(f"Response: I can only answer questions about History.")

            # Show confidence if available
            if "router" in result and "confidence" in result["router"]:
                confidence = result["router"]["confidence"]
                print(f"ML Confidence: {confidence:.3f}")

        except Exception as e:
            print(f"❌ Error: {e}")

    print(f"\n{'='*80}")
    print("Testing completed!")

    # Show logged non-history questions
    log_file = Path("non_history_questions.json")
    if log_file.exists():
        print(f"\nNon-history questions logged to: {log_file}")
        try:
            with open(log_file, 'r') as f:
                logs = json.load(f)
                print(f"Total non-history questions logged: {len(logs)}")
        except json.JSONDecodeError:
            print("Error reading log file. It might be empty or corrupted.")


def clear_logs(filename: str = 'non_history_questions.json'):
    """Clear the log file"""
    log_file = Path(filename)
    if log_file.exists():
        with open(log_file, 'w') as f:
            json.dump([], f)
        print(f"Cleared logs from {filename}")


def run_single_query(pipeline: Pipeline, query: str) -> Dict[str, Any]:
    """Run a single query and return results"""
    result = pipeline.run({"history_filter": {"query": query}})

    if "reader" in result and "answer" in result["reader"]:
        return {
            "type": "history",
            "answer": result["reader"]["answer"],
            "documents": result["reader"]["documents"]
        }
    elif "logger" in result:
        return {
            "type": "non_history",
            "message": "I can only answer questions about History.",
            "logged": True
        }
    else:
        return {
            "type": "error",
            "message": "Unexpected pipeline result"
        }


if __name__ == "__main__":
    test_pipeline()

# Step 1: Build the pipeline
pipeline = build_pipeline()

# Step 2: Run a single query
query = "When did the Roman Empire fall?"
result = run_single_query(pipeline, query)

# Step 3: Display the result
if result['type'] == "history":
    print("✅ HISTORY")
    print(f"Answer: {result['answer'][:300]}")
    print(f"Top document title: {result['documents'][0].meta.get('title', 'Unknown')}")
elif result['type'] == "non_history":
    print("❌ NON-HISTORY")
    print(result['message'])
else:
    print("⚠️ ERROR")
    print(result['message'])

"""Using only the fine-tuned LLM without fallbacks"""

"""
Haystack v2.15.1 History QA Pipeline
Uses smart_balanced_dataset.csv with columns: title, section, text, label
"""

import json
import pandas as pd
from datetime import datetime
from typing import Dict, List, Any
from pathlib import Path

# Haystack v2 imports
from haystack import Pipeline, component, Document
from haystack.components.retrievers import InMemoryBM25Retriever
from haystack.document_stores.in_memory import InMemoryDocumentStore

# ML imports
import torch
import torch.nn.functional as F
from transformers import AutoModelForSequenceClassification, AutoTokenizer


class DocumentClassificationComponent:
    """ML-based document classification component"""

    def __init__(self, model_path: str):
        if not ML_AVAILABLE:
            raise ImportError("ML dependencies not available. Install torch and transformers.")

        self.model = AutoModelForSequenceClassification.from_pretrained(model_path)
        self.tokenizer = AutoTokenizer.from_pretrained(model_path)
        self.model.eval()

        # CORRECT label mappings based on the actual training data
        self.model.config.id2label = {
            0: "Applications",
            1: "Definition",
            2: "Description",
            3: "Diagnosis",
            4: "Examples",
            5: "Function",
            6: "History",      # <- This is what we care about
            7: "Overview",
            8: "Structure",
            9: "Types",
            10: "other"
        }
        self.model.config.label2id = {v: k for k, v in self.model.config.id2label.items()}
        self.id2label = self.model.config.id2label

    def predict(self, title: str = "", text: str = "") -> tuple:
        """Predict if content is history-related"""
        input_text = f"{title} {text}".strip()

        try:
            inputs = self.tokenizer(input_text, return_tensors="pt", truncation=True, max_length=512)
            with torch.no_grad():
                outputs = self.model(**inputs)
                probs = F.softmax(outputs.logits, dim=-1)
                pred_id = torch.argmax(probs, dim=-1).item()
                confidence = probs[0, pred_id].item()
                label = self.id2label[pred_id]

            # Check if it's the "History" section (ID 6)
            is_history = (label == "History" and confidence > 0.6)

            if not is_history and confidence < 0.5:
                return self._keyword_fallback(input_text)

            return is_history, confidence, label

        except Exception as e:
            print(f"ML prediction error: {e}")
            return self._keyword_fallback(input_text)

@component
class HistoryQuestionFilter:
    """Filter component for history-related queries - ML only"""

    def __init__(self, model_path: str = './classification_model'):
        self.classifier = DocumentClassificationComponent(model_path)

    @component.output_types(
        query=str,
        is_history_question=bool,
        filtered_reason=str,
        confidence=float
    )
    def run(self, query: str) -> Dict[str, Any]:
        """Filter queries for history content using ML model only"""
        is_history, confidence, prediction = self.classifier.predict(text=query)
        reason = f"ML classified as {prediction} (confidence: {confidence:.3f})"

        return {
            "query": query,
            "is_history_question": is_history,
            "filtered_reason": reason,
            "confidence": confidence
        }


@component
class ConditionalRouter:
    """Routes queries based on history classification"""

    @component.output_types(
        history_query=str,
        non_history_query=str,
        filtered_reason=str,
        confidence=float
    )
    def run(self, query: str, is_history_question: bool, filtered_reason: str, confidence: float = 0.0) -> Dict[str, Any]:
        """Route based on history classification"""
        if is_history_question:
            return {
                "history_query": query,
                "filtered_reason": filtered_reason,
                "confidence": confidence
            }
        else:
            return {
                "non_history_query": query,
                "filtered_reason": filtered_reason,
                "confidence": confidence
            }


@component
class NonHistoryLogger:
    """Logs non-history questions"""

    def __init__(self, log_file: str = "non_history_questions.json"):
        self.log_file = Path(log_file)

    @component.output_types(
        logged_query=str,
        log_message=str
    )
    def run(self, non_history_query: str, filtered_reason: str, confidence: float = 0.0) -> Dict[str, Any]:
        """Log non-history questions"""
        log_entry = {
            "question": non_history_query,
            "reason": filtered_reason,
            "confidence": confidence,
            "timestamp": datetime.now().isoformat()
        }

        # Load existing logs
        existing_logs = []
        if self.log_file.exists():
            try:
                with open(self.log_file, 'r') as f:
                    existing_logs = json.load(f)
            except (json.JSONDecodeError, FileNotFoundError):
                existing_logs = []

        # Append and save
        existing_logs.append(log_entry)
        with open(self.log_file, 'w') as f:
            json.dump(existing_logs, f, indent=2)

        return {
            "logged_query": non_history_query,
            "log_message": f"Non-history question logged: {non_history_query}"
        }


@component
class SimpleHistoryReader:
    """Generates answers from retrieved history documents"""

    @component.output_types(
        answer=str,
        documents=List[Document]
    )
    def run(self, documents: List[Document], query: str) -> Dict[str, Any]:
        """Generate answer from documents"""
        if not documents:
            return {
                "answer": "No relevant historical information found for your question.",
                "documents": []
            }

        # Create answer from top 3 documents
        context_parts = []
        for doc in documents[:3]:
            content = doc.content[:300] + "..." if len(doc.content) > 300 else doc.content
            title = doc.meta.get('title', 'Unknown')
            context_parts.append(f"From '{title}': {content}")

        context = "\n\n".join(context_parts)
        answer = f"Based on historical records:\n\n{context}"

        return {
            "answer": answer,
            "documents": documents
        }


def load_dataset(csv_path: str = "smart_balanced_dataset.csv", section_filter: str = "History", limit: int = 1000) -> List[Document]:
    """Load documents from CSV with columns: title, section, text, label"""

    if not Path(csv_path).exists():
        raise FileNotFoundError(f"CSV file not found: {csv_path}")

    print(f"Loading dataset from {csv_path}...")
    df = pd.read_csv(csv_path)

    # Verify required columns
    required_columns = ['title', 'section', 'text', 'label']
    missing_columns = [col for col in required_columns if col not in df.columns]
    if missing_columns:
        raise ValueError(f"Missing required columns: {missing_columns}")

    print(f"Dataset loaded with {len(df)} total records")
    print(f"Available sections: {df['section'].value_counts().to_dict()}")

    # Filter by section
    filtered_df = df[df['section'] == section_filter].head(limit)
    print(f"Filtered to {len(filtered_df)} {section_filter} documents")

    if len(filtered_df) == 0:
        raise ValueError(f"No documents found for section '{section_filter}'")

    # Convert to Haystack Documents
    documents = []
    for idx, row in filtered_df.iterrows():
        if pd.isna(row['text']) or not str(row['text']).strip():
            continue

        doc = Document(
            content=str(row['text']),
            meta={
                'title': str(row['title']),
                'section': str(row['section']),
                'label': str(row['label']),
                'doc_id': str(idx)
            }
        )
        documents.append(doc)

    print(f"Successfully created {len(documents)} documents")
    return documents


def build_pipeline(csv_path: str = "smart_balanced_dataset.csv",
                  section_filter: str = "History",
                  limit: int = 1000,
                  model_path: str = './classification_model') -> Pipeline:
    """Build the complete History QA pipeline using ML model only"""

    # Initialize document store
    document_store = InMemoryDocumentStore()

    # Load and store documents
    documents = load_dataset(csv_path, section_filter, limit)
    document_store.write_documents(documents)
    print(f"Document store initialized with {document_store.count_documents()} documents")

    # Initialize components
    history_filter = HistoryQuestionFilter(model_path=model_path)
    router = ConditionalRouter()
    retriever = InMemoryBM25Retriever(document_store)
    reader = SimpleHistoryReader()
    logger = NonHistoryLogger()

    # Build pipeline
    pipeline = Pipeline()
    pipeline.add_component("history_filter", history_filter)
    pipeline.add_component("router", router)
    pipeline.add_component("retriever", retriever)
    pipeline.add_component("reader", reader)
    pipeline.add_component("logger", logger)

    # Connect components
    pipeline.connect("history_filter.query", "router.query")
    pipeline.connect("history_filter.is_history_question", "router.is_history_question")
    pipeline.connect("history_filter.filtered_reason", "router.filtered_reason")
    pipeline.connect("history_filter.confidence", "router.confidence")

    # History path
    pipeline.connect("router.history_query", "retriever.query")
    pipeline.connect("retriever.documents", "reader.documents")
    pipeline.connect("router.history_query", "reader.query")

    # Non-history path
    pipeline.connect("router.non_history_query", "logger.non_history_query")
    pipeline.connect("router.filtered_reason", "logger.filtered_reason")
    pipeline.connect("router.confidence", "logger.confidence")

    return pipeline


def test_pipeline():
    """Test the pipeline with sample questions"""

    try:
        pipeline = build_pipeline()
    except Exception as e:
        print(f"Error building pipeline: {e}")
        return

    # The first 4 questions were taken from the smart_balanced.csv dataset so the answers should also be aligned.
    test_questions = [
        "When were the long-forgotten manuscripts of Tironian notes rediscovered?",
        "In what year did Guang H. Lin reported resonant light absorption by a fabricated nanostructure and rectification of light with frequencies in the visible range.?",
        "What hardware can a software-defined radio use for signal processing?",
        "Angband (1990) was developed by?",
        "What percentage of ectopic pregnancies implant in the ampullary section?",
        "How do male and female frogs differ in their response to advertisement calls?",
        "What is the connection between Loki and Beowulf?",
        "Explain the Linguistic Linear Unit"
    ]

    print("\n" + "="*80)
    print("TESTING HISTORY QA PIPELINE (ML MODEL ONLY)")
    print("="*80)

    for i, question in enumerate(test_questions, 1):
        print(f"\n{i}. Question: {question}")
        print("-" * 60)

        try:
            result = pipeline.run({"history_filter": {"query": question}})

            if "reader" in result and "answer" in result["reader"]:
                # History question
                answer = result["reader"]["answer"]
                documents = result["reader"]["documents"]
                print(f"✅ HISTORY QUESTION")
                print(f"Answer: {answer[:200]}...")
                print(f"Retrieved {len(documents)} documents")

                if documents:
                    print(f"Top document: {documents[0].meta.get('title', 'Unknown')}")

            elif "logger" in result:
                # Non-history question
                print(f"❌ NON-HISTORY QUESTION")
                print(f"Response: I can only answer questions about History.")

            # Show confidence if available
            if "router" in result and "confidence" in result["router"]:
                confidence = result["router"]["confidence"]
                print(f"ML Confidence: {confidence:.3f}")

        except Exception as e:
            print(f"❌ Error: {e}")

    print(f"\n{'='*80}")
    print("Testing completed!")

    # Show logged non-history questions
    log_file = Path("non_history_questions.json")
    if log_file.exists():
        print(f"\nNon-history questions logged to: {log_file}")
        try:
            with open(log_file, 'r') as f:
                logs = json.load(f)
                print(f"Total non-history questions logged: {len(logs)}")
        except json.JSONDecodeError:
            print("Error reading log file. It might be empty or corrupted.")


def clear_logs(filename: str = 'non_history_questions.json'):
    """Clear the log file"""
    log_file = Path(filename)
    if log_file.exists():
        with open(log_file, 'w') as f:
            json.dump([], f)
        print(f"Cleared logs from {filename}")


def run_single_query(pipeline: Pipeline, query: str) -> Dict[str, Any]:
    """Run a single query and return results"""
    result = pipeline.run({"history_filter": {"query": query}})

    if "reader" in result and "answer" in result["reader"]:
        return {
            "type": "history",
            "answer": result["reader"]["answer"],
            "documents": result["reader"]["documents"]
        }
    elif "logger" in result:
        return {
            "type": "non_history",
            "message": "I can only answer questions about History.",
            "logged": True
        }
    else:
        return {
            "type": "error",
            "message": "Unexpected pipeline result"
        }


if __name__ == "__main__":
    test_pipeline()

"""Shows all logged non-history questions"""

import json
from pathlib import Path

log_file = Path("non_history_questions.json")

if log_file.exists():
    try:
        with open(log_file, 'r') as f:
            logs = json.load(f)
            if logs:
                print(f"📄 Total logged non-history questions: {len(logs)}\n")
                for i, entry in enumerate(logs, 1):
                    print(f"{i}. Question: {entry['question']}")
                    print(f"   Reason: {entry['reason']}")
                    print(f"   Confidence: {entry['confidence']:.3f}")
                    print(f"   Timestamp: {entry['timestamp']}\n")
            else:
                print("✅ The log file is empty. No non-history questions logged yet.")
    except json.JSONDecodeError:
        print("⚠️ Error: Log file is corrupted or not in proper JSON format.")
else:
    print("❌ non_history_questions.json does not exist in the current directory.")

# Clear Logs
clear_logs()